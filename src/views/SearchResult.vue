<template>
  <el-container @keydown.enter.native="doSearch">
    <el-header style="display: flex; align-items: center">
      <!--返回首页-->
      <el-button type="primary" @click="$router.push('/')">
        <i class="el-icon-back" /> 首页
      </el-button>
      <el-divider direction="vertical" />
      <!--搜索框-->
      <el-input
        v-model="searchKeyword"
        :placeholder="searchPlaceholder"
        class="homepage-header__input"
        style="vertical-align: center"
      >
        <template #prepend>
          <el-select
            v-model="searchMode"
            placeholder="请选择"
            style="min-width: 100px"
          >
            <el-option
              v-for="modeOption of searchModeOptions"
              :label="modeOption.label"
              :value="modeOption.value"
              :key="modeOption.label"
            />
          </el-select>
        </template>
        <template #append>
          <el-button icon="el-icon-search" @click="doSearch" />
        </template>
      </el-input>
    </el-header>
    <el-main>
      <!--      {{ mode }} : {{ keyword }}-->
      <!--展示搜索结果简略信息-->
      <el-card
        v-for="(paper, i) of papersBasicInfo"
        :key="i"
        style="margin-bottom: 40px"
      >
        <template #header>
          <strong>{{ paper.title }}</strong>
        </template>
        <p><strong>Publication Date:</strong> {{ paper.publicationDate }}</p>
        <p><strong>Abstract:</strong> {{ getLimitedLengthAbs(paper.abs) }}</p>
        <p><strong>Citation:</strong> {{ paper.citation }}</p>
        <el-button
          type="primary"
          size="small"
          style="float:right; margin-bottom: 20px"
        >
          View Detail
        </el-button>
      </el-card>
      <!--分页-->
      <el-pagination
        :current-page.sync="currentPage"
        :page-size="5"
        :total="totalPages"
        layout="prev, pager, next"
        style="text-align: center"
        @current-change="doSearch"
        :small="isPaginationSmall"
      />
    </el-main>
  </el-container>
</template>

<script lang="ts">
import Vue from "vue";
import {
  Card,
  Container,
  Divider,
  Header,
  Input,
  Link,
  Main,
  Option,
  Pagination,
  Select
} from "element-ui";
import { isMobile } from "@/utils/breakpoint";

// 现有的搜索类型
type SearchModes =
  | "paper"
  | "researcher"
  | "domain"
  | "affiliation"
  | "publication";

export default Vue.extend({
  name: "SearchResult",
  props: {
    mode: String,
    keyword: String,
    page: String
  },
  components: {
    [Card.name]: Card,
    [Container.name]: Container,
    [Divider.name]: Divider,
    [Header.name]: Header,
    [Input.name]: Input,
    [Link.name]: Link,
    [Main.name]: Main,
    [Option.name]: Option,
    [Pagination.name]: Pagination,
    [Select.name]: Select
  },
  data() {
    return {
      // 搜索模式
      searchMode: this.mode as SearchModes,
      searchModeOptions: [
        { label: "论文", value: "paper" },
        { label: "学者", value: "researcher" },
        { label: "领域", value: "domain" },
        { label: "机构", value: "affiliation" },
        { label: "出版物", value: "publication" }
      ],
      // 搜索关键词
      searchKeyword: this.keyword,
      // 搜索结果
      papersBasicInfo: [
        {
          title:
            "An Empirical Study Towards Characterizing Deep Learning Development and Deployment Across Different Frameworks and Platforms",
          abs:
            "In popular continuous integration(CI) practice, coding is followed by building, integration and system testing, pre-release inspection, and deploying artifacts. This can reduce integration risk and speed up the development process. But large number of CI build failures may interrupt the normal software development process. So, the failures need to be analyzed and fixed quickly. Although various automated program repair techniques have great potential to resolve software failures, the existing techniques mostly focus on repairing source code. So, those techniques cannot directly help resolve software build failures. Apart from that, a special challenge to fix build failures in CI environment is that the failures are often involved with both source code and build scripts. This paper outlines promising preliminary work towards automatic build repair in CI environment that involves both source code and build script. As the first step, we conducted an empirical study on software build failures and build fix patterns. Based on the findings of the empirical study, we developed an approach that can automatically fix build errors involving build scripts. We plan to extend this repair approach considering both source code and build script. Moreover, we plan to quantify our automatic fixes by user study and comparison between fixes generated by our approach and actual fixes.",
          publicationDate: 2019,
          citation: 0
        },
        {
          title:
            "An Empirical Study Towards Characterizing Deep Learning Development and Deployment Across Different Frameworks and Platforms",
          abs:
            "In popular continuous integration(CI) practice, coding is followed by building, integration and system testing, pre-release inspection, and deploying artifacts. This can reduce integration risk and speed up the development process. But large number of CI build failures may interrupt the normal software development process. So, the failures need to be analyzed and fixed quickly. Although various automated program repair techniques have great potential to resolve software failures, the existing techniques mostly focus on repairing source code. So, those techniques cannot directly help resolve software build failures. Apart from that, a special challenge to fix build failures in CI environment is that the failures are often involved with both source code and build scripts. This paper outlines promising preliminary work towards automatic build repair in CI environment that involves both source code and build script. As the first step, we conducted an empirical study on software build failures and build fix patterns. Based on the findings of the empirical study, we developed an approach that can automatically fix build errors involving build scripts. We plan to extend this repair approach considering both source code and build script. Moreover, we plan to quantify our automatic fixes by user study and comparison between fixes generated by our approach and actual fixes.",
          publicationDate: 2019,
          citation: 0
        },
        {
          title:
            "An Empirical Study Towards Characterizing Deep Learning Development and Deployment Across Different Frameworks and Platforms",
          abs:
            "In popular continuous integration(CI) practice, coding is followed by building, integration and system testing, pre-release inspection, and deploying artifacts. This can reduce integration risk and speed up the development process. But large number of CI build failures may interrupt the normal software development process. So, the failures need to be analyzed and fixed quickly. Although various automated program repair techniques have great potential to resolve software failures, the existing techniques mostly focus on repairing source code. So, those techniques cannot directly help resolve software build failures. Apart from that, a special challenge to fix build failures in CI environment is that the failures are often involved with both source code and build scripts. This paper outlines promising preliminary work towards automatic build repair in CI environment that involves both source code and build script. As the first step, we conducted an empirical study on software build failures and build fix patterns. Based on the findings of the empirical study, we developed an approach that can automatically fix build errors involving build scripts. We plan to extend this repair approach considering both source code and build script. Moreover, we plan to quantify our automatic fixes by user study and comparison between fixes generated by our approach and actual fixes.",
          publicationDate: 2019,
          citation: 0
        },
        {
          title:
            "An Empirical Study Towards Characterizing Deep Learning Development and Deployment Across Different Frameworks and Platforms",
          abs:
            "In popular continuous integration(CI) practice, coding is followed by building, integration and system testing, pre-release inspection, and deploying artifacts. This can reduce integration risk and speed up the development process. But large number of CI build failures may interrupt the normal software development process. So, the failures need to be analyzed and fixed quickly. Although various automated program repair techniques have great potential to resolve software failures, the existing techniques mostly focus on repairing source code. So, those techniques cannot directly help resolve software build failures. Apart from that, a special challenge to fix build failures in CI environment is that the failures are often involved with both source code and build scripts. This paper outlines promising preliminary work towards automatic build repair in CI environment that involves both source code and build script. As the first step, we conducted an empirical study on software build failures and build fix patterns. Based on the findings of the empirical study, we developed an approach that can automatically fix build errors involving build scripts. We plan to extend this repair approach considering both source code and build script. Moreover, we plan to quantify our automatic fixes by user study and comparison between fixes generated by our approach and actual fixes.",
          publicationDate: 2019,
          citation: 0
        },
        {
          title:
            "An Empirical Study Towards Characterizing Deep Learning Development and Deployment Across Different Frameworks and Platforms",
          abs:
            "In popular continuous integration(CI) practice, coding is followed by building, integration and system testing, pre-release inspection, and deploying artifacts. This can reduce integration risk and speed up the development process. But large number of CI build failures may interrupt the normal software development process. So, the failures need to be analyzed and fixed quickly. Although various automated program repair techniques have great potential to resolve software failures, the existing techniques mostly focus on repairing source code. So, those techniques cannot directly help resolve software build failures. Apart from that, a special challenge to fix build failures in CI environment is that the failures are often involved with both source code and build scripts. This paper outlines promising preliminary work towards automatic build repair in CI environment that involves both source code and build script. As the first step, we conducted an empirical study on software build failures and build fix patterns. Based on the findings of the empirical study, we developed an approach that can automatically fix build errors involving build scripts. We plan to extend this repair approach considering both source code and build script. Moreover, we plan to quantify our automatic fixes by user study and comparison between fixes generated by our approach and actual fixes.",
          publicationDate: 2019,
          citation: 0
        }
      ],
      currentPage: Number(this.page),
      totalPages: 50
    };
  },
  computed: {
    searchPlaceholder(): string {
      const placeholders = {
        paper: "请输入论文相关信息，如标题、摘要、作者",
        researcher: "请输入学者相关信息，如姓名、机构",
        domain: "请输入研究领域相关信息，如名称",
        affiliation: "请输入机构相关信息，如名称",
        publication: "请输入出版物相关信息，如名称"
      };
      return placeholders[this.searchMode];
    },
    isPaginationSmall(): boolean {
      return isMobile();
    }
  },
  mounted() {
    this.fetchSearchResult(
      this.searchMode,
      this.searchKeyword,
      this.currentPage
    );
  },
  watch: {
    "$route.params.mode"() {
      this.fetchSearchResult(
        this.searchMode,
        this.searchKeyword,
        this.currentPage
      );
    },
    "$route.query.keyword"() {
      this.fetchSearchResult(
        this.searchMode,
        this.searchKeyword,
        this.currentPage
      );
    },
    "$route.query.page"() {
      this.fetchSearchResult(
        this.searchMode,
        this.searchKeyword,
        this.currentPage
      );
    }
  },
  methods: {
    getLimitedLengthAbs(abs: string) {
      // 截取前500个字符，相当于前100词左右
      // 据某统计数据表示，平均单词长度为4-5个字母
      const LIMIT = 500;
      return abs.length > LIMIT ? abs.substr(0, LIMIT) + "..." : abs;
    },
    // 搜索
    doSearch() {
      if (!this.searchKeyword) {
        this.$message.warning("请输入搜索内容");
        return;
      }
      this.$router.push({
        path: `/result/${this.searchMode}`,
        query: {
          keyword: this.searchKeyword,
          page: this.currentPage.toString()
        }
      });
    },
    fetchSearchResult(mode: SearchModes, keyword: string, page = 1) {
      console.log("fetching", mode, keyword, page);
    }
  }
});
</script>

<style scoped></style>
