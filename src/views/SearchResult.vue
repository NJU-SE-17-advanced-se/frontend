<template>
  <el-container @keydown.enter.native="doSearch">
    <el-header style="display: flex; align-items: center">
      <!--返回首页-->
      <el-button type="primary" @click="$router.push('/')">
        <i class="el-icon-back" /> 首页
      </el-button>
      <el-divider direction="vertical" />
      <!--搜索框-->
      <search-bar
        v-model="searchKeyword"
        :mode="searchMode"
        :options="searchModeOptions"
        @mode-change="updateSearchMode"
        @search="doSearch"
      />
    </el-header>
    <el-main>
      <!--展示搜索结果简略信息-->
      <el-card
        v-for="(paper, i) of papersBasicInfo"
        :key="i"
        style="margin-bottom: 40px"
      >
        <template #header>
          <strong>{{ paper.title }}</strong>
        </template>
        <p><strong>Publication Date:</strong> {{ paper.publicationDate }}</p>
        <p><strong>Abstract:</strong> {{ getLimitedLengthAbs(paper.abs) }}</p>
        <p><strong>Citation:</strong> {{ paper.citation }}</p>
        <el-button
          type="primary"
          size="small"
          style="float:right; margin-bottom: 20px"
        >
          View Detail
        </el-button>
      </el-card>
      <!--分页-->
      <el-pagination
        :current-page.sync="currentPage"
        :page-size="5"
        :total="totalPages"
        layout="prev, pager, next"
        style="text-align: center"
        @current-change="doSearch"
        :small="isPaginationSmall"
      />
    </el-main>
  </el-container>
</template>

<script lang="ts">
import Vue from "vue";
import {
  Card,
  Container,
  Divider,
  Header,
  Input,
  Main,
  Option,
  Pagination,
  Select
} from "element-ui";
import SearchBar from "@/components/SearchBar.vue";
import { isMobile } from "@/utils/breakpoint";
import { SearchModes } from "@/interfaces/Search";

export default Vue.extend({
  name: "SearchResult",
  props: {
    mode: String,
    keyword: String,
    page: String
  },
  components: {
    [Card.name]: Card,
    [Container.name]: Container,
    [Divider.name]: Divider,
    [Header.name]: Header,
    [Input.name]: Input,
    [Main.name]: Main,
    [Option.name]: Option,
    [Pagination.name]: Pagination,
    [Select.name]: Select,
    SearchBar
  },
  data() {
    return {
      // 搜索模式
      searchMode: this.mode as SearchModes,
      searchModeOptions: [
        { label: "论文", value: "paper" },
        { label: "学者", value: "researcher" },
        { label: "领域", value: "domain" },
        { label: "机构", value: "affiliation" },
        { label: "出版物", value: "publication" }
      ],
      // 搜索关键词
      searchKeyword: this.keyword,
      // 搜索结果
      papersBasicInfo: [
        {
          title:
            "An Empirical Study Towards Characterizing Deep Learning Development and Deployment Across Different Frameworks and Platforms",
          abs:
            "In popular continuous integration(CI) practice, coding is followed by building, integration and system testing, pre-release inspection, and deploying artifacts. This can reduce integration risk and speed up the development process. But large number of CI build failures may interrupt the normal software development process. So, the failures need to be analyzed and fixed quickly. Although various automated program repair techniques have great potential to resolve software failures, the existing techniques mostly focus on repairing source code. So, those techniques cannot directly help resolve software build failures. Apart from that, a special challenge to fix build failures in CI environment is that the failures are often involved with both source code and build scripts. This paper outlines promising preliminary work towards automatic build repair in CI environment that involves both source code and build script. As the first step, we conducted an empirical study on software build failures and build fix patterns. Based on the findings of the empirical study, we developed an approach that can automatically fix build errors involving build scripts. We plan to extend this repair approach considering both source code and build script. Moreover, we plan to quantify our automatic fixes by user study and comparison between fixes generated by our approach and actual fixes.",
          publicationDate: 2019,
          citation: 0
        },
        {
          title:
            "An Empirical Study Towards Characterizing Deep Learning Development and Deployment Across Different Frameworks and Platforms",
          abs:
            "In popular continuous integration(CI) practice, coding is followed by building, integration and system testing, pre-release inspection, and deploying artifacts. This can reduce integration risk and speed up the development process. But large number of CI build failures may interrupt the normal software development process. So, the failures need to be analyzed and fixed quickly. Although various automated program repair techniques have great potential to resolve software failures, the existing techniques mostly focus on repairing source code. So, those techniques cannot directly help resolve software build failures. Apart from that, a special challenge to fix build failures in CI environment is that the failures are often involved with both source code and build scripts. This paper outlines promising preliminary work towards automatic build repair in CI environment that involves both source code and build script. As the first step, we conducted an empirical study on software build failures and build fix patterns. Based on the findings of the empirical study, we developed an approach that can automatically fix build errors involving build scripts. We plan to extend this repair approach considering both source code and build script. Moreover, we plan to quantify our automatic fixes by user study and comparison between fixes generated by our approach and actual fixes.",
          publicationDate: 2019,
          citation: 0
        },
        {
          title:
            "An Empirical Study Towards Characterizing Deep Learning Development and Deployment Across Different Frameworks and Platforms",
          abs:
            "In popular continuous integration(CI) practice, coding is followed by building, integration and system testing, pre-release inspection, and deploying artifacts. This can reduce integration risk and speed up the development process. But large number of CI build failures may interrupt the normal software development process. So, the failures need to be analyzed and fixed quickly. Although various automated program repair techniques have great potential to resolve software failures, the existing techniques mostly focus on repairing source code. So, those techniques cannot directly help resolve software build failures. Apart from that, a special challenge to fix build failures in CI environment is that the failures are often involved with both source code and build scripts. This paper outlines promising preliminary work towards automatic build repair in CI environment that involves both source code and build script. As the first step, we conducted an empirical study on software build failures and build fix patterns. Based on the findings of the empirical study, we developed an approach that can automatically fix build errors involving build scripts. We plan to extend this repair approach considering both source code and build script. Moreover, we plan to quantify our automatic fixes by user study and comparison between fixes generated by our approach and actual fixes.",
          publicationDate: 2019,
          citation: 0
        },
        {
          title:
            "An Empirical Study Towards Characterizing Deep Learning Development and Deployment Across Different Frameworks and Platforms",
          abs:
            "In popular continuous integration(CI) practice, coding is followed by building, integration and system testing, pre-release inspection, and deploying artifacts. This can reduce integration risk and speed up the development process. But large number of CI build failures may interrupt the normal software development process. So, the failures need to be analyzed and fixed quickly. Although various automated program repair techniques have great potential to resolve software failures, the existing techniques mostly focus on repairing source code. So, those techniques cannot directly help resolve software build failures. Apart from that, a special challenge to fix build failures in CI environment is that the failures are often involved with both source code and build scripts. This paper outlines promising preliminary work towards automatic build repair in CI environment that involves both source code and build script. As the first step, we conducted an empirical study on software build failures and build fix patterns. Based on the findings of the empirical study, we developed an approach that can automatically fix build errors involving build scripts. We plan to extend this repair approach considering both source code and build script. Moreover, we plan to quantify our automatic fixes by user study and comparison between fixes generated by our approach and actual fixes.",
          publicationDate: 2019,
          citation: 0
        },
        {
          title:
            "An Empirical Study Towards Characterizing Deep Learning Development and Deployment Across Different Frameworks and Platforms",
          abs:
            "In popular continuous integration(CI) practice, coding is followed by building, integration and system testing, pre-release inspection, and deploying artifacts. This can reduce integration risk and speed up the development process. But large number of CI build failures may interrupt the normal software development process. So, the failures need to be analyzed and fixed quickly. Although various automated program repair techniques have great potential to resolve software failures, the existing techniques mostly focus on repairing source code. So, those techniques cannot directly help resolve software build failures. Apart from that, a special challenge to fix build failures in CI environment is that the failures are often involved with both source code and build scripts. This paper outlines promising preliminary work towards automatic build repair in CI environment that involves both source code and build script. As the first step, we conducted an empirical study on software build failures and build fix patterns. Based on the findings of the empirical study, we developed an approach that can automatically fix build errors involving build scripts. We plan to extend this repair approach considering both source code and build script. Moreover, we plan to quantify our automatic fixes by user study and comparison between fixes generated by our approach and actual fixes.",
          publicationDate: 2019,
          citation: 0
        }
      ],
      currentPage: Number(this.page),
      totalPages: 50
    };
  },
  computed: {
    isPaginationSmall(): boolean {
      return isMobile();
    }
  },
  mounted() {
    this.fetchSearchResult(
      this.searchMode,
      this.searchKeyword,
      this.currentPage
    );
  },
  watch: {
    "$route.params.mode"() {
      this.fetchSearchResult(
        this.searchMode,
        this.searchKeyword,
        this.currentPage
      );
    },
    "$route.query.keyword"() {
      this.fetchSearchResult(
        this.searchMode,
        this.searchKeyword,
        this.currentPage
      );
    },
    "$route.query.page"() {
      this.fetchSearchResult(
        this.searchMode,
        this.searchKeyword,
        this.currentPage
      );
    }
  },
  methods: {
    getLimitedLengthAbs(abs: string) {
      // 截取前500个字符，相当于前100词左右
      // 据某统计数据表示，平均单词长度为4-5个字母
      const LIMIT = 500;
      return abs.length > LIMIT ? abs.substr(0, LIMIT) + "..." : abs;
    },
    updateSearchMode(mode: SearchModes) {
      this.searchMode = mode;
    },
    // 搜索
    doSearch() {
      if (!this.searchKeyword) {
        this.$message.warning("请输入搜索内容");
        return;
      }
      this.$router.push({
        path: `/result/${this.searchMode}`,
        query: {
          keyword: this.searchKeyword,
          page: this.currentPage.toString()
        }
      });
    },
    // 获取搜索结果
    fetchSearchResult(mode: SearchModes, keyword: string, page = 1) {
      console.log("fetching", mode, keyword, page);
    }
  }
});
</script>
